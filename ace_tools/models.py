"""Data models for the ACE Skills Session Inspector.

This module provides Pydantic models for loading, parsing, and analyzing
Claude Agent SDK transcripts captured during ACE task and skill loop execution.

The models are designed to work with JSONL transcript files generated by
ClaudeSDKClient hooks and provide structured access to session events,
tool invocations, and metadata for curator analysis.
"""

from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Literal, Optional

from pydantic import BaseModel, Field, field_validator

from claude_agent_sdk import (
    AssistantMessage,
    Message,
    ResultMessage,
    ToolResultBlock,
    ToolUseBlock,
)


class EventRecord(BaseModel):
    """Normalized schema for a single event in an ACE trajectory.

    EventRecord wraps SDK message types with additional metadata for
    inspection, filtering, and annotation by curators.

    Attributes:
        event_type: Classification of the event type
        timestamp: When the event occurred (ISO format)
        sdk_block: Raw SDK message payload (serialized)
        curator_tags: Annotations added by curators for categorization
        loop_type: Whether this event occurred in task or skill loop
        trajectory_id: Unique identifier linking events to a trajectory
    """

    event_type: Literal[
        "assistant_message", "tool_use", "tool_result", "subagent_stop", "user_prompt"
    ]
    timestamp: datetime
    sdk_block: dict[str, Any] = Field(
        description="Raw SDK message payload for faithful reconstruction"
    )
    curator_tags: list[str] = Field(
        default_factory=list, description="Tags for curator annotations"
    )
    loop_type: Literal["task", "skill"] = Field(
        default="task", description="Loop context where event occurred"
    )
    trajectory_id: Optional[str] = Field(
        default=None, description="Links event to parent trajectory"
    )

    @classmethod
    def from_message(
        cls,
        msg: Message,
        loop_type: Literal["task", "skill"] = "task",
        trajectory_id: Optional[str] = None,
    ) -> EventRecord:
        """Create an EventRecord from a Claude SDK Message.

        Args:
            msg: SDK Message object (AssistantMessage, ToolUseBlock, etc.)
            loop_type: Whether message is from task or skill loop
            trajectory_id: Optional trajectory identifier

        Returns:
            EventRecord with populated fields based on message type
        """
        # Determine event type
        if isinstance(msg, AssistantMessage):
            event_type = "assistant_message"
        elif isinstance(msg, ToolUseBlock):
            event_type = "tool_use"
        elif isinstance(msg, ToolResultBlock):
            event_type = "tool_result"
        elif isinstance(msg, ResultMessage):
            event_type = "subagent_stop"
        else:
            event_type = "user_prompt"

        # Extract timestamp
        timestamp_value = getattr(msg, "timestamp", None)
        if timestamp_value is None:
            timestamp = datetime.now()
        elif isinstance(timestamp_value, datetime):
            timestamp = timestamp_value
        elif isinstance(timestamp_value, str):
            try:
                timestamp = datetime.fromisoformat(timestamp_value)
            except ValueError:
                timestamp = datetime.now()
        else:
            timestamp = datetime.now()

        # Extract metadata
        metadata = getattr(msg, "metadata", {}) or {}
        extracted_loop_type = metadata.get("loop_type", loop_type)
        extracted_trajectory_id = metadata.get("trajectory_id", trajectory_id)

        # Serialize SDK block
        if hasattr(msg, "model_dump"):
            sdk_block = msg.model_dump()
        else:
            sdk_block = msg.__dict__.copy()

        return cls(
            event_type=event_type,
            timestamp=timestamp,
            sdk_block=sdk_block,
            loop_type=extracted_loop_type,
            trajectory_id=extracted_trajectory_id,
        )

    @field_validator("timestamp", mode="before")
    @classmethod
    def parse_timestamp(cls, value: Any) -> datetime:
        """Parse timestamp from various formats."""
        if isinstance(value, datetime):
            return value
        if isinstance(value, str):
            try:
                return datetime.fromisoformat(value)
            except ValueError:
                return datetime.now()
        return datetime.now()


class SkillOutcome(BaseModel):
    """Derived outcome from ToolUseBlock + ToolResultBlock pairs.

    SkillOutcome represents the complete lifecycle of a single tool
    invocation, including inputs, outputs, success status, and metadata
    useful for curator analysis.

    Attributes:
        tool_name: Name of the tool invoked
        tool_input: Input parameters passed to the tool
        tool_output: Output returned by the tool
        success: Whether the tool execution succeeded
        duration_ms: Optional execution duration in milliseconds
        permission_mode: Permission context (allow/ask/deny)
        tool_use_id: Unique identifier for the tool use block
        timestamp: When the tool was invoked
    """

    tool_name: str
    tool_input: dict[str, Any]
    tool_output: str
    success: bool = True
    duration_ms: Optional[int] = None
    permission_mode: Optional[str] = None
    tool_use_id: Optional[str] = None
    timestamp: Optional[datetime] = None

    @classmethod
    def from_tool_blocks(
        cls, tool_use: ToolUseBlock, tool_result: Optional[ToolResultBlock] = None
    ) -> SkillOutcome:
        """Create SkillOutcome from paired ToolUseBlock and ToolResultBlock.

        Args:
            tool_use: SDK ToolUseBlock containing invocation details
            tool_result: Optional SDK ToolResultBlock with execution results

        Returns:
            SkillOutcome with merged information from both blocks
        """
        tool_input = getattr(tool_use, "input", {})
        if not isinstance(tool_input, dict):
            tool_input = {}

        tool_use_id = getattr(tool_use, "id", None)
        timestamp_value = getattr(tool_use, "timestamp", None)

        # Parse timestamp
        timestamp = None
        if isinstance(timestamp_value, datetime):
            timestamp = timestamp_value
        elif isinstance(timestamp_value, str):
            try:
                timestamp = datetime.fromisoformat(timestamp_value)
            except ValueError:
                pass

        # Extract result information
        if tool_result:
            content = getattr(tool_result, "content", "")
            if isinstance(content, list):
                tool_output = "\n".join(str(item) for item in content)
            else:
                tool_output = str(content)
            success = not getattr(tool_result, "is_error", False)
        else:
            tool_output = ""
            success = False

        return cls(
            tool_name=tool_use.name,
            tool_input=tool_input,
            tool_output=tool_output,
            success=success,
            tool_use_id=tool_use_id,
            timestamp=timestamp,
        )


class SessionModel(BaseModel):
    """Wrapper for ClaudeSDKClient transcripts with analysis capabilities.

    SessionModel provides structured access to a complete ACE execution
    session, including all events, metadata, and convenience methods for
    filtering and extracting specific patterns.

    Attributes:
        session_id: Unique identifier for this session
        task_id: Task identifier (may be same as session_id)
        events: Chronological list of all events in the session
        playbook_context: Delta playbook state at session start
        created_at: Session creation timestamp
        metadata: Additional session metadata
    """

    session_id: str
    task_id: str
    events: list[EventRecord] = Field(default_factory=list)
    playbook_context: dict[str, Any] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.now)
    metadata: dict[str, Any] = Field(default_factory=dict)

    def filter_events(
        self,
        event_type: Optional[str] = None,
        loop_type: Optional[Literal["task", "skill"]] = None,
        curator_tags: Optional[list[str]] = None,
    ) -> list[EventRecord]:
        """Filter events by type, loop context, or curator tags.

        Args:
            event_type: Filter by specific event type (e.g., "tool_use")
            loop_type: Filter by task or skill loop
            curator_tags: Filter by presence of specific curator tags

        Returns:
            List of EventRecords matching all specified filters
        """
        filtered = self.events

        if event_type:
            filtered = [e for e in filtered if e.event_type == event_type]

        if loop_type:
            filtered = [e for e in filtered if e.loop_type == loop_type]

        if curator_tags:
            tag_set = set(curator_tags)
            filtered = [e for e in filtered if tag_set.intersection(e.curator_tags)]

        return filtered

    def get_tool_calls(self) -> list[EventRecord]:
        """Get all tool use events from the session.

        Returns:
            List of EventRecords with event_type="tool_use"
        """
        return self.filter_events(event_type="tool_use")

    def get_tool_results(self) -> list[EventRecord]:
        """Get all tool result events from the session.

        Returns:
            List of EventRecords with event_type="tool_result"
        """
        return self.filter_events(event_type="tool_result")

    def get_skill_outcomes(self) -> list[SkillOutcome]:
        """Extract paired tool use/result blocks as SkillOutcomes.

        Returns:
            List of SkillOutcome objects representing complete tool invocations
        """
        outcomes: list[SkillOutcome] = []
        tool_uses: dict[str, EventRecord] = {}

        for event in self.events:
            if event.event_type == "tool_use":
                tool_use_id = event.sdk_block.get("id")
                if tool_use_id:
                    tool_uses[tool_use_id] = event

            elif event.event_type == "tool_result":
                tool_use_id = event.sdk_block.get("tool_use_id")
                if tool_use_id and tool_use_id in tool_uses:
                    use_event = tool_uses[tool_use_id]

                    # Reconstruct blocks from SDK data
                    try:
                        tool_use_block = ToolUseBlock(**use_event.sdk_block)
                        tool_result_block = ToolResultBlock(**event.sdk_block)
                        outcome = SkillOutcome.from_tool_blocks(
                            tool_use_block, tool_result_block
                        )
                        outcomes.append(outcome)
                    except Exception:
                        # If reconstruction fails, create minimal outcome
                        outcomes.append(
                            SkillOutcome(
                                tool_name=use_event.sdk_block.get("name", "unknown"),
                                tool_input=use_event.sdk_block.get("input", {}),
                                tool_output=str(event.sdk_block.get("content", "")),
                                success=not event.sdk_block.get("is_error", False),
                            )
                        )

        return outcomes

    def get_assistant_messages(self) -> list[EventRecord]:
        """Get all assistant message events.

        Returns:
            List of EventRecords with event_type="assistant_message"
        """
        return self.filter_events(event_type="assistant_message")

    def get_skill_events(self) -> list[EventRecord]:
        """Get all events from skill loop context.

        Returns:
            List of EventRecords with loop_type="skill"
        """
        return self.filter_events(loop_type="skill")

    def get_task_events(self) -> list[EventRecord]:
        """Get all events from task loop context.

        Returns:
            List of EventRecords with loop_type="task"
        """
        return self.filter_events(loop_type="task")

    def add_curator_tag(self, event_index: int, tag: str) -> None:
        """Add a curator tag to a specific event.

        Args:
            event_index: Index of event in events list
            tag: Tag string to add to curator_tags
        """
        if 0 <= event_index < len(self.events):
            if tag not in self.events[event_index].curator_tags:
                self.events[event_index].curator_tags.append(tag)

    def get_duration_seconds(self) -> float:
        """Calculate total session duration from first to last event.

        Returns:
            Duration in seconds, or 0.0 if less than 2 events
        """
        if len(self.events) < 2:
            return 0.0

        first = self.events[0].timestamp
        last = self.events[-1].timestamp
        return (last - first).total_seconds()


class TranscriptLoader:
    """Utility class to load and parse JSONL transcript files.

    TranscriptLoader reads transcript files generated by ACE hook handlers
    and reconstructs SessionModel objects with proper grouping by session_id
    and task_id.
    """

    @staticmethod
    def load_transcript(path: Path) -> list[SessionModel]:
        """Load JSONL transcript file and group into SessionModel objects.

        Args:
            path: Path to JSONL transcript file

        Returns:
            List of SessionModel objects, one per unique session

        Raises:
            FileNotFoundError: If path does not exist
            ValueError: If transcript format is invalid
        """
        if not path.exists():
            raise FileNotFoundError(f"Transcript file not found: {path}")

        # Group events by session_id
        sessions_data: dict[str, dict[str, Any]] = {}

        with path.open("r") as fh:
            for line_num, line in enumerate(fh, 1):
                line = line.strip()
                if not line:
                    continue

                try:
                    payload = json.loads(line)
                except json.JSONDecodeError as exc:
                    raise ValueError(
                        f"Invalid JSON at line {line_num}: {exc}"
                    ) from exc

                # Extract session identifiers
                metadata = payload.get("metadata", {})
                session_id = metadata.get("session_id", "default")
                task_id = metadata.get("task_id") or metadata.get("trajectory_id", session_id)
                loop_type = metadata.get("loop_type", "task")
                trajectory_id = metadata.get("trajectory_id")

                # Initialize session if new
                if session_id not in sessions_data:
                    sessions_data[session_id] = {
                        "session_id": session_id,
                        "task_id": task_id,
                        "events": [],
                        "playbook_context": metadata.get("playbook_context", {}),
                        "created_at": None,
                        "metadata": {},
                    }

                # Parse message type and create EventRecord
                event_type = TranscriptLoader._infer_event_type(payload)

                timestamp_value = payload.get("timestamp")
                if timestamp_value:
                    try:
                        timestamp = datetime.fromisoformat(timestamp_value)
                    except (ValueError, TypeError):
                        timestamp = datetime.now()
                else:
                    timestamp = datetime.now()

                event = EventRecord(
                    event_type=event_type,
                    timestamp=timestamp,
                    sdk_block=payload,
                    loop_type=loop_type,
                    trajectory_id=trajectory_id,
                )

                sessions_data[session_id]["events"].append(event)

                # Set created_at from first event
                if sessions_data[session_id]["created_at"] is None:
                    sessions_data[session_id]["created_at"] = timestamp

        # Convert to SessionModel objects
        sessions = []
        for session_data in sessions_data.values():
            if session_data["created_at"] is None:
                session_data["created_at"] = datetime.now()

            sessions.append(SessionModel(**session_data))

        return sessions

    @staticmethod
    def _infer_event_type(payload: dict[str, Any]) -> str:
        """Infer event type from SDK message payload structure.

        Args:
            payload: Deserialized SDK message dict

        Returns:
            Event type string compatible with EventRecord.event_type
        """
        msg_type = payload.get("type", "")

        if msg_type == "message" and payload.get("role") == "assistant":
            return "assistant_message"
        elif "tool_use" in msg_type or (payload.get("name") and "input" in payload):
            return "tool_use"
        elif "tool_result" in msg_type or "tool_use_id" in payload:
            return "tool_result"
        elif msg_type == "result" or payload.get("stop_reason"):
            return "subagent_stop"
        else:
            return "user_prompt"

    @staticmethod
    def load_from_task_trajectory(trajectory: Any) -> SessionModel:
        """Create SessionModel from TaskTrajectory object.

        This method provides compatibility with the existing TaskTrajectory
        structure used in ace-task.py.

        Args:
            trajectory: TaskTrajectory object from ace-task.py

        Returns:
            SessionModel with events extracted from trajectory messages
        """
        events = []

        for msg in trajectory.messages:
            metadata = getattr(msg, "metadata", {}) or {}
            loop_type = metadata.get("loop_type", "task")
            trajectory_id = metadata.get("trajectory_id", trajectory.task_id)

            event = EventRecord.from_message(
                msg, loop_type=loop_type, trajectory_id=trajectory_id
            )
            events.append(event)

        # Extract playbook context if available
        playbook_context = {}
        if hasattr(trajectory, "playbook_context"):
            playbook_context = trajectory.playbook_context

        return SessionModel(
            session_id=trajectory.task_id,
            task_id=trajectory.task_id,
            events=events,
            playbook_context=playbook_context,
            created_at=datetime.fromisoformat(trajectory.created_at),
        )


__all__ = [
    "EventRecord",
    "SessionModel",
    "SkillOutcome",
    "TranscriptLoader",
]
